// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/policies/policy.d.ts
declare module '~amqp10/lib/policies/policy' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import { WindowPolicy, CreditPolicy } from '~amqp10/lib/policies/policy_utilities';

/**
 * The default policy for amqp10 clients.
 */
class Policy implements Policy.Overrides {
    defaultSubjects: boolean;
    reconnect: Policy.Reconnect;
    connect: Policy.Connect;
    session: Policy.Session;
    senderLink: Policy.SenderLink;
    receiverLink: Policy.ReceiverLink;
    
    /**
     * Creates a new default Policy.
     * @param overrides - override values for the default policy
     */
    constructor(overrides?: Policy.Overrides);
    
    /**
     * Parses an address for use when connecting to an AMQP 1.0 broker
     *
     * @param address - the address to parse
     * @returns Parsed URL.
     */
    parseAddress(address: string): Policy.Address;
}

namespace Policy {
    /** Policy Configuration. */
    export interface Overrides {
        /**
         * support subjects in link names with the following characteristics:
         * receiver: "amq.topic/news", means a filter on the ReceiverLink will be made
         *           for messages send with a subject "news"
         *
         * sender: "amq.topic/news", will automatically set "news" as the subject for
         *         messages sent on this link, unless the user explicitly overrides
         *         the subject.
         */
        defaultSubjects?: boolean;
        
        reconnect?: Reconnect;
        
        connect?: Connect;
        
        session?: Session;
        
        senderLink?: SenderLink;
        
        receiverLink?: ReceiverLink;
    }
    
    export interface Reconnect {
        retries?: number;
        strategy?: "fibonacci" | "exponential";
        forever?: boolean;
    }
    
    export interface Connect {
        options?: ConnectOptions;
    }
    
    export interface ConnectOptions {
        containerId?: string;
        hostname?: string;
        maxFrameSize?: number;
        channelMax?: number;
        idleTimeout?: number;
        outgoingLocales?: string;
        incomingLocales?: string;
        offeredCapabilities?: any;
        desiredCapabilities?: any;
        properties?: any;
        sslOptions?: SSLOptions;
    }
    
    export interface SSLOptions {
          keyFile?: string;
          certFile?: string;
          caFile?: string;
          rejectUnauthorized?: boolean;
    }
    
    export interface Session {
        options?: SessionOptions;
        window?: WindowPolicy;
        windowQuantum?: number;
        enableSessionFlowControl?: boolean;
    }
    
    export interface SessionOptions {
        nextOutgoingId?: number;
        incomingWindow?: number;
        outgoingWindow?: number;
    }
    
    export interface SenderLink {
        /** Only for createReceiver: alias to [link.attach.name] */
        name?: string;
        attach?: SenderLinkAttach;
        callback?: "settled" | "sent";
        encoder?: any;
        reattach?: any;
    }
    
    export interface SenderLinkAttach {
        name?: string;
        role?: boolean;
        senderSettleMode?: number;
        maxMessageSize?: number;
        initialDeliveryCount?: number;
    }
    
    export interface ReceiverLink {
        /** Only for createReceiver: alias to [link.attach.name] */
        name?: string;
        attach?: ReceiverLinkAttach;
        credit?: CreditPolicy;
        creditQuantum?: number;
        decoder?: any;
        reattach?: any;
    }
    
    export interface ReceiverLinkAttach {
        name?: string;
        role?: boolean;
        receiverSettleMode?: number;
        maxMessageSize?: number;
        initialDeliveryCount?: number;
    }
    
    export interface Address {
        host: string;
        path: string;
        protocol: string;
        href: string;
        port: number;
        rootUri: string;
        
        user?: string;
        pass?: string;
    }
}

export = Policy;
}
declare module 'amqp10/lib/policies/policy' {
import main = require('~amqp10/lib/policies/policy');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/policies/event_hub_policy.d.ts
declare module '~amqp10/lib/policies/event_hub_policy' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import ServiceBusPolicy = require('~amqp10/lib/policies/service_bus_policy');

export = ServiceBusPolicy;
}
declare module 'amqp10/lib/policies/event_hub_policy' {
import main = require('~amqp10/lib/policies/event_hub_policy');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/policies/service_bus_policy.d.ts
declare module '~amqp10/lib/policies/service_bus_policy' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import Policy = require('~amqp10/lib/policies/policy');

const policy: Policy;
export = policy;
}
declare module 'amqp10/lib/policies/service_bus_policy' {
import main = require('~amqp10/lib/policies/service_bus_policy');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/policies/service_bus_queue_policy.d.ts
declare module '~amqp10/lib/policies/service_bus_queue_policy' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import ServiceBusPolicy = require('~amqp10/lib/policies/service_bus_policy');

export = ServiceBusPolicy;
}
declare module 'amqp10/lib/policies/service_bus_queue_policy' {
import main = require('~amqp10/lib/policies/service_bus_queue_policy');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/policies/service_bus_topic_policy.d.ts
declare module '~amqp10/lib/policies/service_bus_topic_policy' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import ServiceBusPolicy = require('~amqp10/lib/policies/service_bus_policy');

export = ServiceBusPolicy;
}
declare module 'amqp10/lib/policies/service_bus_topic_policy' {
import main = require('~amqp10/lib/policies/service_bus_topic_policy');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/policies/qpid_java_policy.d.ts
declare module '~amqp10/lib/policies/qpid_java_policy' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import Policy = require('~amqp10/lib/policies/policy');

const policy: Policy;
export = policy;
}
declare module 'amqp10/lib/policies/qpid_java_policy' {
import main = require('~amqp10/lib/policies/qpid_java_policy');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/policies/activemq_policy.d.ts
declare module '~amqp10/lib/policies/activemq_policy' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import Policy = require('~amqp10/lib/policies/policy');
const policy: Policy;
export = policy;
}
declare module 'amqp10/lib/policies/activemq_policy' {
import main = require('~amqp10/lib/policies/activemq_policy');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/connection.d.ts
declare module '~amqp10/lib/connection' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import { EventEmitter } from 'events';

import Policy = require('~amqp10/lib/policies/policy');
import Session = require('~amqp10/lib/session');

/**
 * Connection states, from AMQP 1.0 spec:
 *
 <dl>
 <dt>START</dt>
 <dd><p>In this state a Connection exists, but nothing has been sent or received. This is the
 state an implementation would be in immediately after performing a socket connect or
 socket accept.</p></dd>
 <dt>HDR-RCVD</dt>
 <dd><p>In this state the Connection header has been received from our peer, but we have not
 yet sent anything.</p></dd>
 <dt>HDR-SENT</dt>
 <dd><p>In this state the Connection header has been sent to our peer, but we have not yet
 received anything.</p></dd>
 <dt>OPEN-PIPE</dt>
 <dd><p>In this state we have sent both the Connection header and the open frame, but we have not yet received anything.
 </p></dd>
 <dt>OC-PIPE</dt>
 <dd><p>In this state we have sent the Connection header, the open
 frame, any pipelined Connection traffic, and the close frame,
 but we have not yet received anything.</p></dd>
 <dt>OPEN-RCVD</dt>
 <dd><p>In this state we have sent and received the Connection header, and received an
 open frame from our peer, but have not yet sent an
 open frame.</p></dd>
 <dt>OPEN-SENT</dt>
 <dd><p>In this state we have sent and received the Connection header, and sent an
 open frame to our peer, but have not yet received an
 open frame to our peer, but have not yet received an
 open frame.</p></dd>
 <dt>CLOSE-PIPE</dt>
 <dd><p>In this state we have send and received the Connection header, sent an
 open frame, any pipelined Connection traffic, and the
 close frame, but we have not yet received an
 open frame.</p></dd>
 <dt>OPENED</dt>
 <dd><p>In this state the Connection header and the open frame
 have both been sent and received.</p></dd>
 <dt>CLOSE-RCVD</dt>
 <dd><p>In this state we have received a close frame indicating
 that our partner has initiated a close. This means we will never have to read anything
 more from this Connection, however we can continue to write frames onto the Connection.
 If desired, an implementation could do a TCP half-close at this point to shutdown the
 read side of the Connection.</p></dd>
 <dt>CLOSE-SENT</dt>
 <dd><p>In this state we have sent a close frame to our partner.
 It is illegal to write anything more onto the Connection, however there may still be
 incoming frames. If desired, an implementation could do a TCP half-close at this point
 to shutdown the write side of the Connection.</p></dd>
 <dt>DISCARDING</dt>
 <dd><p>The DISCARDING state is a variant of the CLOSE_SENT state where the
 close is triggered by an error. In this case any incoming frames on
 the connection MUST be silently discarded until the peer's close frame
 is received.</p></dd>
 <dt>END</dt>
 <dd><p>In this state it is illegal for either endpoint to write anything more onto the
 Connection. The Connection may be safely closed and discarded.</p></dd>
 </dl>
 *
 * Connection negotiation state diagram from AMQP 1.0 spec:
 *
 <pre>
              R:HDR +=======+ S:HDR             R:HDR[!=S:HDR]
           +--------| START |-----+    +--------------------------------+
           |        +=======+     |    |                                |
          \\|/                    \\|/   |                                |
      +==========+             +==========+ S:OPEN                      |
 +----| HDR-RCVD |             | HDR-SENT |------+                      |
 |    +==========+             +==========+      |      R:HDR[!=S:HDR]  |
 |   S:HDR |                      | R:HDR        |    +-----------------+
 |         +--------+      +------+              |    |                 |
 |                 \\|/    \\|/                   \\|/   |                 |
 |                +==========+               +-----------+ S:CLOSE      |
 |                | HDR-EXCH |               | OPEN-PIPE |----+         |
 |                +==========+               +-----------+    |         |
 |           R:OPEN |      | S:OPEN              | R:HDR      |         |
 |         +--------+      +------+      +-------+            |         |
 |        \\|/                    \\|/    \\|/                  \\|/        |
 |   +===========+             +===========+ S:CLOSE       +---------+  |
 |   | OPEN-RCVD |             | OPEN-SENT |-----+         | OC-PIPE |--+
 |   +===========+             +===========+     |         +---------+  |
 |  S:OPEN |                      | R:OPEN      \\|/           | R:HDR   |
 |         |       +========+     |          +------------+   |         |
 |         +----- >| OPENED |< ---+          | CLOSE-PIPE |< -+         |
 |                 +========+                +------------+             |
 |           R:CLOSE |    | S:CLOSE              | R:OPEN               |
 |         +---------+    +-------+              |                      |
 |        \\|/                    \\|/             |                      |
 |   +============+          +=============+     |                      |
 |   | CLOSE-RCVD |          | CLOSE-SENT* |< ---+                      |
 |   +============+          +=============+                            |
 | S:CLOSE |                      | R:CLOSE                             |
 |         |         +=====+      |                                     |
 |         +------- >| END |< ----+                                     |
 |                   +=====+                                            |
 |                     /|\                                              |
 |    S:HDR[!=R:HDR]    |                R:HDR[!=S:HDR]                 |
 +----------------------+-----------------------------------------------+
 </pre>
 *
 * R:<b>CTRL</b> = Received <b>CTRL</b>
 *
 * S:<b>CTRL</b> = Sent <b>CTRL</b>
 *
 * Also could be DISCARDING if an error condition triggered the CLOSE
 */
class Connection extends EventEmitter {
    policy: Policy.Connect;
    connected: boolean;
    connectedTo: any;

    local: any;
    remote: any;

    connSM: any;

    static Connected: "connection:connected";
    static Disconnected: "connection:disconnected";
    /**
     * On receipt of a frame not handled internally (e.g. not a BEGIN/CLOSE/SASL).
     * Provides received frame as an argument.
     */
    static FrameReceived: "connection:frameReceived";
    /**
     * Since 'error' events are "special" in Node (as in halt-the-process special),
     * using a custom event for errors we receive from the other endpoint. Provides
     * received AMQPError as an argument.
     */
    static ErrorReceived: "connection:errorReceived";

    /**
     * Creates a new Connection instance.
     *
     * @param connectPolicy ConnectPolicy from a Policy instance
     * @constructor
     */
    constructor(connectPolicy: Policy.Connect);

    /**
     * Open a connection to the given (parsed) address (@see {@link AMQPClient}).
     *
     * @param address   Contains at least protocol, host and port, may contain user/pass, path.
     * @param sasl      If given, contains a "negotiate" method that, given address and a callback, will run through SASL negotiations.
     */
    open(address: Policy.Address, sasl?: { negotiate(address: Policy.Address, callback: Function): void; }): void;

    close(): void;

    sendFrame(frame: any): void;

    associateSession(session: Session): number;
    dissociateSession(channel: number): void;

    sendHeader(header: Buffer): void;
}

export = Connection;
}
declare module 'amqp10/lib/connection' {
import main = require('~amqp10/lib/connection');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/session.d.ts
declare module '~amqp10/lib/session' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import { EventEmitter } from 'events';

import Policy = require('~amqp10/lib/policies/policy');
import Connection = require('~amqp10/lib/connection');
import ReceiverLink = require('~amqp10/lib/receiver_link');
import SenderLink = require('~amqp10/lib/sender_link');
import Link = require('~amqp10/lib/link');

/**
 * A Session is a bidirectional sequential conversation between two containers that provides a
 * grouping for related links. Sessions serve as the context for link communication. Any number
 * of links of any directionality can be <i>attached</i> to a given Session. However, a link
 * may be attached to at most one Session at a time.
 *
 * Session states, from AMQP 1.0 spec:
 *
 <dl>
 <dt>UNMAPPED</dt>
 <dd><p>In the UNMAPPED state, the Session endpoint is not mapped to any incoming or outgoing
 channels on the Connection endpoint. In this state an endpoint cannot send or receive
 frames.</p></dd>
 <dt>BEGIN-SENT</dt>
 <dd><p>In the BEGIN-SENT state, the Session endpoint is assigned an outgoing channel number,
 but there is no entry in the incoming channel map. In this state the endpoint may send
 frames but cannot receive them.</p></dd>
 <dt>BEGIN-RCVD</dt>
 <dd><p>In the BEGIN-RCVD state, the Session endpoint has an entry in the incoming channel
 map, but has not yet been assigned an outgoing channel number. The endpoint may receive
 frames, but cannot send them.</p></dd>
 <dt>MAPPED</dt>
 <dd><p>In the MAPPED state, the Session endpoint has both an outgoing channel number and an
 entry in the incoming channel map. The endpoint may both send and receive
 frames.</p></dd>
 <dt>END-SENT</dt>
 <dd><p>In the END-SENT state, the Session endpoint has an entry in the incoming channel map,
 but is no longer assigned an outgoing channel number. The endpoint may receive frames,
 but cannot send them.</p></dd>
 <dt>END-RCVD</dt>
 <dd><p>In the END-RCVD state, the Session endpoint is assigned an outgoing channel number,
 but there is no entry in the incoming channel map. The endpoint may send frames, but
 cannot receive them.</p></dd>
 <dt>DISCARDING</dt>
 <dd><p>The DISCARDING state is a variant of the END-SENT state where the <code>end</code>
 is triggered by an error. In this case any incoming frames on the session MUST be
 silently discarded until the peer's <code>end</code> frame is received.</p></dd>
 </dl>
 <pre>
                         UNMAPPED< ------------------+
                            |                        |
                    +-------+-------+                |
            S:BEGIN |               | R:BEGIN        |
                    |               |                |
                   \\|/             \\|/               |
                BEGIN-SENT      BEGIN-RCVD           |
                    |               |                |
                    |               |                |
            R:BEGIN |               | S:BEGIN        |
                    +-------+-------+                |
                            |                        |
                           \\|/                       |
                          MAPPED                     |
                            |                        |
              +-------------+-------------+          |
 S:END(error) |       S:END |             | R:END    |
              |             |             |          |
             \\|/           \\|/           \\|/         |
          DISCARDING     END-SENT      END-RCVD      |
              |             |             |          |
              |             |             |          |
        R:END |       R:END |             | S:END    |
              +-------------+-------------+          |
                            |                        |
                            |                        |
                            +------------------------+
  </pre>
 *
 * There is no obligation to retain a Session Endpoint when it is in the UNMAPPED state, i.e.
 * the UNMAPPED state is equivalent to a NONEXISTENT state.
 *
 * Note: This implementation *assumes* it is the client, and thus will always be the one BEGIN-ing a Session.
 *
 * @param {Connection} conn     Connection to bind session to.
 * @constructor
 */
class Session extends EventEmitter {
    connection: Connection;
    mapped: boolean;
    remoteChannel: any;
    sessionSM: any;
    
    static Mapped: "mapped";
    static Unmapped: "unmapped";
    static ErrorReceived: "errorReceived";
    static DispositionReceived: "disposition";
    
    /**
     * Create a new Session instance.
     * 
     * @param {Connection} conn - Connection to bind session to.
     * @constructor
     */
    constructor(conn: Connection);
    
    begin(sessionPolicy: Policy.Session): void;
    
    createLink(linkPolicy: Policy.ReceiverLink): ReceiverLink;
    createLink(linkPolicy: Policy.SenderLink): SenderLink;
    
    addWindow(windowSize: number, flowOptions?: Link.FlowOptions): void;
    
    detachLink(link: Link): Promise<void>;
    
    end(): void;
}

export = Session;
}
declare module 'amqp10/lib/session' {
import main = require('~amqp10/lib/session');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/link.d.ts
declare module '~amqp10/lib/link' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import { EventEmitter } from 'events';
import Session = require('~amqp10/lib/session');
import Policy = require('~amqp10/lib/policies/policy');

type LinkPolicy = Policy.SenderLink | Policy.ReceiverLink;

class Link extends EventEmitter {
    policy: LinkPolicy;
    session: Session;
    handle: string;
    remote: Link.Remote;
    deliveryCount: number;
    linkSM: any;

    name: string;
    role: boolean;
    linkCredit: number;
    totalCredits: number;
    available: number;
    drain: boolean;

    /** On receipt of a message.  Message payload given as argument. */
    static MessageReceived: "message";

    /** Since "error" events are "special" in Node (as in halt-the-process special),
     * using a custom event for errors we receive from the other endpoint. Provides
     * received AMQPError as an argument.
     */
    static ErrorReceived: "errorReceived";

    /** On link credit changed. */
    static CreditChange: "creditChange";

    /** On completion of detach. */
    static Attached: "attached";

    /** On completion of detach. */
    static Detached: "detached";

    constructor(session: Session, handle: string, linkPolicy: LinkPolicy);

    state(): string;
    attach(): void;
    detach(options?: Link.DetachOptions): Promise<void>;
    forceDetach(): void;
    flow(flowOptions?: Link.FlowOptions): void;
    shouldReatttach(): boolean;
}

namespace Link {
    export interface Remote {
        handle: string;
        attach: any;
        detach: any;
    }

    export interface FlowOptions {
        channel?: string;
        handle?: string;
        linkCredit?: number;
        nextIncomingId?: string;
        incomingWindow?: number;
        nextOutgoingId?: string;
        outgoingWindow?: number;
        available?: boolean;
        deliveryCount?: number;
        drain?: boolean;
    }

    export interface DetachOptions {
        handle?: string;
        channel?: string;
        closed?: boolean;
        error?: any;
    }
}

export = Link;
}
declare module 'amqp10/lib/link' {
import main = require('~amqp10/lib/link');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/policies/policy_utilities.d.ts
declare module '~amqp10/lib/policies/policy_utilities' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import * as Policy from '~amqp10/lib/policies/policy';
import Session = require('~amqp10/lib/session');
import Link = require('~amqp10/lib/link');

export type WindowPolicy = (session: Session) => void;

export const WindowPolicies: {
    RefreshAtHalf: WindowPolicy;
    RefreshAtEmpty: WindowPolicy;
    DoNotRefresh: WindowPolicy;
};

export type CreditPolicy = (link: Link, options?: any) => void;

export const CreditPolicies: {
    RefreshAtHalf: CreditPolicy;
    RefreshAtEmpty: CreditPolicy;
    RefreshSettled(treshold: number): CreditPolicy;
    DoNotRefresh: CreditPolicy;
};

export const SenderCallbackPolicies: {
    /** Only callback when settled Disposition received from recipient. */
    OnSettle: 'settled';
    
    /** Callback as soon as sent, will not call-back again if future disposition results in error. */
    OnSent: 'sent';
};

export function Merge(newPolicy: Policy.Overrides, base: Policy.Overrides): typeof newPolicy & typeof base;

/** Receiver links process messages N at a time, only renewing credits on ack. */
export function RenewOnSettle(initialCredit: number, treshold: number, basePolicy?: Policy.Overrides): Policy;
}
declare module 'amqp10/lib/policies/policy_utilities' {
export * from '~amqp10/lib/policies/policy_utilities';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/streams/receiver_stream.d.ts
declare module '~amqp10/lib/streams/receiver_stream' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import { Readable } from 'stream';

class ReceiverStream extends Readable { }

export = ReceiverStream;
}
declare module 'amqp10/lib/streams/receiver_stream' {
import main = require('~amqp10/lib/streams/receiver_stream');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/streams/sender_stream.d.ts
declare module '~amqp10/lib/streams/sender_stream' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import { Writable } from 'stream';

class SenderStream extends Writable { }

export = SenderStream;
}
declare module 'amqp10/lib/streams/sender_stream' {
import main = require('~amqp10/lib/streams/sender_stream');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/amqp_client.d.ts
declare module '~amqp10/lib/amqp_client' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import { EventEmitter } from 'events';

import Policy = require('~amqp10/lib/policies/policy');
import ReceiverLink = require('~amqp10/lib/receiver_link');
import SenderLink = require('~amqp10/lib/sender_link');
import _ReceiverStream = require('~amqp10/lib/streams/receiver_stream');
import _SenderStream = require('~amqp10/lib/streams/sender_stream');

/**
 * AMQPClient is the top-level class for interacting with node-amqp10.  Instantiate this class, connect, and then send/receive
 * as needed and behind the scenes it will do the appropriate work to setup and teardown connections, sessions, and links and manage flow.
 * The code does its best to avoid exposing AMQP-specific types and attempts to convert them where possible, but on the off-chance you
 * need to speak AMQP-specific (e.g. to set a filter to a described-type), you can use node-amqp-encoder and the
 * translator adapter to convert it to our internal types.  See simple_eventhub_test.js for an example.
 *
 * Configuring AMQPClient is done through a Policy class.  By default, DefaultPolicy will be used - it assumes AMQP defaults wherever
 * possible, and for values with no spec-defined defaults it tries to assume something reasonable (e.g. timeout, max message size).
 *
 * To define a new policy, you can merge your values into an existing one by calling AMQPClient.policies.merge(yourPolicy, existingPolicy).
 * This does a deep-merge, allowing you to only replace values you need.  For instance, if you wanted the default sender settle policy to be auto-settle instead of mixed,
 * you could just use
 *
 <pre>
 var AMQP = require('amqp10');
 var client = new AMQP.Client(AMQP.Policy.merge({
   senderLink: {
     attach: {
       senderSettleMode: AMQP.Constants.senderSettleMode.settled
     }
   }
 });
 </pre>
 *
 * Obviously, setting some of these options requires some in-depth knowledge of AMQP, so I've tried to define specific policies where I can.
 * For instance, for Azure EventHub connections, you can use the pre-build EventHubPolicy.
 *
 * Also, within the policy, see the encoder and decoder defined in the send/receive policies.  These define what to do with the message
 * sent/received, and by default do a simple pass-through, leaving the encoding to/decoding from AMQP-specific types up to the library which
 * does a best-effort job.  See EventHubPolicy for a more complicated example, turning objects into UTF8-encoded buffers of JSON-strings.
 */
class AMQPClient extends EventEmitter {
    policy: Policy;
    
    static ErrorReceived: "client:errorReceived"; 
    static ConnectionOpened: "connection:opened";
    static ConnectionClosed: "connection:closed";
    
    /**
     * Creates a new AMQPClient instance using DefaultPolicy.
     * @constructor
     */
    constructor();
    
    /**
     * Creates a new AMQPClient instance by overriding DefaultPolicy using given overrides.
     *
     * @param policyOverrides - Additional overrides for the default policy
     * @constructor
     */
    constructor(policyOverrides?: Policy.Overrides);
    
    /**
     * Creates a new AMQPClient instance.
     *
     * @param policy - Policy to use for connection, sessions, links, etc.  Defaults to DefaultPolicy.
     * @param [policyOverrides] - Additional overrides for the provided policy
     * @constructor
     */
    constructor(policy: Policy, policyOverrides?: Policy.Overrides);
    
    /**
     * Connects to a given AMQP server endpoint. Sets the default queue, so e.g.
     * amqp://my-activemq-host/my-queue-name would set the default queue to
     * my-queue-name for future send/receive calls.
     * 
     * @param url - URI to connect to, right now only supports `amqp` and `amqps` as protocol.
     */
    connect(url: string): Promise<this>;
    
    /**
     * Creates a sender link for the given address, with optional link policy.
     *
     * @param address                An address to connect this link to. If not provided will use default queue from connection uri.
     * @param [policyOverrides]      Policy overrides used for creating this sender link
     * @param [policyOverrides.name] Explicitly set a name for this link, this is an alias to [policyOverrides.attach.name]
     */
    createSender(address: string, policyOverrides?: Policy.SenderLink): Promise<SenderLink>;
    
    /**
     * Creates a sender link wrapped as a Writable stream.
     *
     * @param {String} address                Address used for link creation
     * @param {Object} [policyOverrides]      Policy overrides used for creating this sender link
     */
    createSenderStream(address: string, policyOverrides?: Policy.SenderLink): Promise<_SenderStream>;
    
    
    /**
     * Creates a receiver link for the given address, with optional link policy. The
     * promise returned resolves to a link that is an EventEmitter, which can be
     * used to listen for 'message' events.
     *
     * @param {String} address                An address to connect this link to.  If not provided will use default queue from connection uri.
     * @param {Object} [policyOverrides]      Policy overrides used for creating this receiver link
     * @param {String} [policyOverrides.name] Explicitly set a name for this link, this is an alias to [policyOverrides.attach.name]
     */
    createReceiver(address: string, policyOverrides?: Policy.ReceiverLink): Promise<ReceiverLink>;
    
    /**
     * Creates a receiver link wrapped as a Readable stream
     *
     * @param {String} address                Address used for link creation
     * @param {Object} [policyOverrides]      Policy overrides used for creating the receiver link
     */
    createReceiverStream(address: string, policyOverrides?: Policy.ReceiverLink): Promise<_ReceiverStream>;
    
    /**
     * Disconnect tears down any existing connection with appropriate Close
     * performatives and TCP socket teardowns.
     */
    disconnect(): Promise<void>;
}

namespace AMQPClient {
    export type ReceiverStream = _ReceiverStream;
    export type SenderStream = _SenderStream;
}

export = AMQPClient;
}
declare module 'amqp10/lib/amqp_client' {
import main = require('~amqp10/lib/amqp_client');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/constants.d.ts
declare module '~amqp10/lib/constants' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

export const defaultPort: number;
export const defaultTlsPort: number;

export const minMaxFrameSize: number;
export const defaultMaxFrameSize: number;
export const defaultChannelMax: number;
export const defaultIdleTimeout: number;

export const requiredLocale: string;
export const defaultOutgoingLocales: string;
export const defaultIncomingLocales: string;

export const defaultHandleMax: number;

export const amqpVersion: Buffer;
export const saslVersion: Buffer;

export const session: {
    defaultIncomingWindow: number;
    defaultOutgoingWindow: number;
    defaultOutgoingId: number;
};

export const frameType: {
    amqp: number;
    sasl: number;
};

export const saslOutcomes: {
    ok: number;
    auth: number;
    sys: number;
    sys_perm: number;
    sys_temp: number;
    
    0: string;
    1: string;
    2: string;
    3: string;
    4: string;
};

export const linkRole: {
    sender: boolean;
    receiver: boolean;
};

export const senderSettleMode: {
    unsettled: number;
    settled: number;
    mixed: number;
};

export const receiverSettleMode: {
    autoSettle: number;
    settleOnDisposition: number;
};

export const terminusDurability: {
    none: number;
    configuration: number;
    unsettledState: number;
};

export const terminusExpiryPolicy: {
    linkDetach: "link-detach";
    sessionEnd: "session-end";
    connectionClose: "connection-close";
    never: "never";
};

export const distributionMode: {
    move: "move";
    copy: "copy";
};
}
declare module 'amqp10/lib/constants' {
export * from '~amqp10/lib/constants';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/errors.d.ts
declare module '~amqp10/lib/errors' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

/** The base error all amqp10 Errors inherit from. */
export class BaseError extends Error {
    name: string;
    message: string;
    stack: string;

    constructor(message: string);
}

export class ProtocolError extends BaseError {
    name: "AmqpProtocolError";
    condition: string;
    description: string;
    errorInfo: any;

    constructor(condition: string, description?: string, errorInfo?: any);
}

/** AMQP Header is malformed. */
export class MalformedHeaderError extends BaseError {
    name: "AmqpMalformedHeaderError";

    constructor(header: string);
}

/** Method or feature is not yet implemented. */
export class NotImplementedError extends BaseError {
    name: "AmqpNotImplementedError";

    constructor(feature: string);
}

/** Payload is malformed or cannot be parsed. */
export class MalformedPayloadError extends BaseError {
    name: "AmqpMalformedPayloadError";

    constructor(payload: string);
}

/** Given object cannot be encoded successfully. */
export class EncodingError extends BaseError {
    name: "AmqpEncodingError";
    value: any;

    /**
     * @param value - The value that caused the encoding error.
     * @param message - An optional message giving context to the error.
     */
    constructor(value: any, message?: string);
}

/** Violation of AMQP flow control. */
export class OverCapacityError extends BaseError {
    name: "AmqpOverCapacityError";

    constructor(msg: string);
}

/** Authentication failure. */
export class AuthenticationError extends BaseError {
    name: "AmqpAuthenticationError";

    constructor(msg: string);
}

/** Argument missing or incorrectly defined. */
export class ArgumentError extends BaseError {
    name: "AmqpArgumentError";

    constructor(arg: string |string[]);
}

/** Invalid state. */
export class InvalidStateError extends BaseError {
    name: "AmqpInvalidStateError";

    constructor(msg: string);
}

/** Connection error. */
export class ConnectionError extends BaseError {
    name: "AmqpConnectionError";

    constructor(msg: string);
}

/** Disconnected error. */
export class DisconnectedError extends BaseError {
    name: "AmqpDisconnectedError";

    constructor(msg: string);
}

/** AMQP Version error. */
export class VersionError extends BaseError {
    name: "AmqpVersionError";

    constructor(msg: string);
}

/**
 * Invalid subject specified for receiver or sender link creation.
 */
export class InvalidSubjectError extends BaseError {
    name: "AmqpInvalidSubjectError";

    constructor(subject: string);
}

/**
 * Used to signal transport-related errors
 */
export class TransportError extends BaseError {
    name: "AmqpTransportError";

    constructor(msg: string);
}
}
declare module 'amqp10/lib/errors' {
export * from '~amqp10/lib/errors';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/transport/index.d.ts
declare module '~amqp10/lib/transport/index' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import { EventEmitter } from 'events';
import { Address } from '~amqp10/lib/policies/policy';

// declare class TransportProvider implements provider.TransportProvider {
//     registerTransport(protocol: string, transportFactory: provider.TransportFactory): void;
//     getTransportFor(protocol: string): provider.TransportFactory;
// }

const provider: provider.TransportProvider;

namespace provider {
        
    export interface TransportProvider {
        registerTransport(protocol: string, transportFactory: TransportFactory): void;
        getTransportFor(protocol: string): TransportFactory;
    }

    export interface TransportFactory extends EventEmitter {
        connect(address: Address): void;
        write(data: string | Buffer): void;
        end(): void;
        destroy(): void;
    }
}

export = provider;
}
declare module 'amqp10/lib/transport/index' {
import main = require('~amqp10/lib/transport/index');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/types/described_type.d.ts
declare module '~amqp10/lib/types/described_type' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

/**
 * Described type, as described in the AMQP 1.0 spec as follows:
 *
 *            constructor                       untyped bytes
 *                 |                                 |
 *     +-----------+-----------+   +-----------------+-----------------+
 *     |                       |   |                                   |
 *...  0x00 0xA1 0x03 "URL" 0xA1   0x1E "http://example.org/hello-world"  ...
 *          |             |  |     |                                   |
 *          +------+------+  |     |                                   |
 *                 |         |     |                                   |
 *            descriptor     |     +------------------+----------------+
 *                           |                        |
 *                           |         string value encoded according
 *                           |             to the str8-utf8 encoding
 *                           |
 *                primitive format code
 *              for the str8-utf8 encoding
 *
 * (Note: this example shows a string-typed descriptor, which should be considered reserved)
 */
class DescribedType<T> {
    descriptor: number;
    value: T;

    /**
     * @constructor
     * @param descriptorOrType  Descriptor for the type (can be any valid AMQP type, including another described type), or the type itself.
     * @param value             Value of the described type (can also be any valid AMQP type, including another described type).
     */
    constructor(descriptorOrType: number | DescribedType.DescriptorType, value: T);
    
    getValue(): T;
}

namespace DescribedType {
    export interface DescriptorType {
        prototype: {
            Descriptor: {
                code: number;
            };
        };
    }
}

export = DescribedType;
}
declare module 'amqp10/lib/types/described_type' {
import main = require('~amqp10/lib/types/described_type');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/adapters/translate_encoder.d.ts
declare module '~amqp10/lib/adapters/translate_encoder' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

function encoder(data: any): any;

export = encoder;
}
declare module 'amqp10/lib/adapters/translate_encoder' {
import main = require('~amqp10/lib/adapters/translate_encoder');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/frames.d.ts
declare module '~amqp10/lib/frames' {
/**
 * Types only
 */
export interface Frame {
    type: number;
}

export interface OpenFrame {
    containerId: string;
    hostname: string;
    maxFrameSize: number;
    channelMax: number;
    idleTimeout: number;
    outgoingLocales: string;
    incomingLocales: string;
    offeredCapabilities: string;
    desiredCapabilities: string;
    properties: Object;
}

export interface BeginFrame {
    remoteChannel: number;
    nextOutgoingId: number;
    incomingWindow: number;
    outgoingWindow: number;
    handleMax: number;
    offeredCapabilities: string;
    desiredCapabilities: string;
    properties: Object;
}

export interface AttachFrame {
    name: string;
    handle: string;
    role: boolean;
    sndSettleMode: string;
    rcvSettleMode: string;
    source: any;
    target: any;
    unsettled: { [key: string]: any };
    incompleteUnsettled: boolean;
    initialDeliveryCount: number;
    maxMessageSize: number;
    offeredCapabilities: string;
    desiredCapabilities: string;
    properties: Object;
}

export interface FlowFrame {
    nextIncomingId: number;
    incomingWindow: number;
    nextOutgoingId: number;
    outgoingWindow: number;
    handle: string;
    deliveryCount: number;
    linkCredit: number;
    available: number;
    drain: boolean;
    echo: boolean;
    properties: Object;
}

export interface TransferFrame {
    handle: string;
    deliveryId: number;
    deliveryTag: number;
    messageFormat: number;
    settled: boolean;
    more: boolean;
    rcvSettleMode: number;
    state: any;
    resume: boolean;
    aborted: boolean;
    batchable: boolean;
}

export interface DispositionFrame {
    role: boolean;
    first: number;
    last: number;
    settled: number;
    state: any;
    batchable: boolean;
}

export interface DetachFrame {
    handle: string;
    closed: boolean;
    error: any;
}

export interface EndFrame {
    error: any;
}

export interface CloseFrame {
    error: any;
}

// SASL frames
export interface SaslMechanismsFrame {
    saslServerMechanisms: string;
}

export interface SaslInitFrame {
    mechanism: string;
    initialResponse: Buffer; // Is this right?
    hostname: string;
}

export interface SaslChallengeFrame {
    challenge: Buffer; // Is this right?
}

export interface SaslResponseFrame {
    response: Buffer; // Is this right?
}

export interface SaslOutcomeFrame {
    code: number;
    additionalData: Buffer;
}
}
declare module 'amqp10/lib/frames' {
export * from '~amqp10/lib/frames';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/receiver_link.d.ts
declare module '~amqp10/lib/receiver_link' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import Link = require('~amqp10/lib/link');
import Session = require('~amqp10/lib/session');
import Policy = require('~amqp10/lib/policies/policy');
import { DeliveryState } from '~amqp10/lib/types/delivery_state';
import { BaseError } from '~amqp10/lib/errors';
import { TransferFrame } from '~amqp10/lib/frames';

type Message = ReceiverLink.Message;

class ReceiverLink extends Link {
    policy: Policy.ReceiverLink;
    settledMessagesSinceLastCredit: number;
    linkCredits: number;
    totalCredits: number;

    constructor(session: Session, handle: string, linkPolicy: Policy.ReceiverLink);

    addCredits(credits: number, flowOptions?: Link.FlowOptions): void;

    /**
     * Settle a message (or array of messages) with an Accepted delivery outcome
     *
     * @param {String|Array}  [message] message, or array of messages to settle
     */
    accept(message?: Message | Message[]): void;

    /**
     * Settle a message (or array of messages) with a Rejected delivery outcome
     *
     * @param {String|Array}  [message] message, or array of messages to settle
     * @param {String}        [error] error that caused the message to be rejected
     */
    reject(message?: Message | Message[], error?: string): void;

    /**
     * Settle a message (or array of messages) with a Released delivery outcome
     *
     * @param {String|Array}  [message] message, or array of messages to settle
     */
    release(message?: Message | Message[]): void;

    /**
     * Settle a message (or array of messages) with a Modified delivery outcome
     *
     * @param {String|Array}  [message] message, or array of messages to settle
     * @param {Object}        [options] options used for a Modified outcome
     */
    modify(message?: Message | Message[], options?: ReceiverLink.ModifyOptions): void;

    /**
     * Settle a message (or array of messages) with a given delivery state
     *
     * @param {String|Array}  [message] message, or array of messages to settle
     * @param {Object}        [state] outcome of message delivery
     */
    settle(message?: Message | Message[], state?: DeliveryState): void;

    /** Message event handler */
    on(event: "message", listener: (msg: Message, frame: TransferFrame) => void): this;
    /** Error event handler */
    on(event: "errorReceived", listener: (err: BaseError) => void): this;
    on(event: "creditChange" | "attached" | "detached", listener: Function): this;
    on(event: string, listener: Function): this;
}

namespace ReceiverLink {
    export interface Dictionary<T> {
        [key: string]: T;
    }

    export interface ModifyOptions {
        /** count the transfer as an unsuccessful delivery attempt. */
        deliveryFailed?: boolean;

        /** prevent redelivery. */
        undeliverableHere?: boolean;

        /** message attributes to combine with existing annotations. */
        messageAnnotations?: Object;
    }

    export interface Message extends Dictionary<any> {
        body?: any;

        properties?: Dictionary<any>;

        /**
         * Annotations for the message, if any.  See AMQP spec for details, and server for specific
         * annotations that might be relevant (e.g. x-opt-partition-key on EventHub).  If node-amqp-encoder'd
         * map is given, it will be translated to appropriate internal types.  Simple maps will be converted
         * to AMQP Fields type as defined in the spec.
         */
        annotations?: Dictionary<any>;

        applicationProperties?: Dictionary<any>;
    }
}

export = ReceiverLink;
}
declare module 'amqp10/lib/receiver_link' {
import main = require('~amqp10/lib/receiver_link');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/types/forced_type.d.ts
declare module '~amqp10/lib/types/forced_type' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

/**
 * ForcedType coerces the encoder to encode to the given type, regardless of what it might think.
 */
class ForcedType<T> {
    /**
     * Create a new ForcedType instance.
     *  
     * @param typeName          Symbolic name or specific code (e.g. 'long', or 0xA0)
     * @param value             Value to encode, should be compatible or bad things will occur
     * @constructor
     */
    constructor(typeName: string, value: T);
    
    inspect(depth?: number): string;
    
    valueOf(): T;
}

export = ForcedType;
}
declare module 'amqp10/lib/types/forced_type' {
import main = require('~amqp10/lib/types/forced_type');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/types/composite_type.d.ts
declare module '~amqp10/lib/types/composite_type' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import DescribedType = require('~amqp10/lib/types/described_type');
import ForcedType = require('~amqp10/lib/types/forced_type');

export abstract class Composite {
    value: any[];
    
    static fields: Field<any>[];
    static descriptor: CompositeDescriptor;
    
    constructor(fields?: Object);
    
    toDescribedType(): DescribedType<any>;
    inspect(depth?: number): string;
}

export interface CompositeConstructor {
    new <T>(): Composite;
    prototype: Composite;
    
    fields: Field<any>[];
    descriptor: CompositeDescriptor;
}

export interface CompositeDescriptor {
    code: number;
    name: string;
}

export interface Field<T> {
    name: string;
    type: string;
    mandatory?: boolean;
    default?: T;
    requires?: Constructor | (() => any);
    multiple?: boolean;
}

export type Constructor = { new (): any; };

export interface CompositeDefinition {
    name: string;
    code: number;
    fields: Field<any>[];
}

export function defineComposite(definition: CompositeDefinition): CompositeConstructor;
export function defineComposite(Base: Constructor, definition: CompositeDefinition): CompositeConstructor;

export function wrapField<T>(field: Field<T>, value?: Composite): Composite;
export function wrapField<T>(field: Field<T>, value?: T | T[] | ForcedType<T>): T | ForcedType<T>;
}
declare module 'amqp10/lib/types/composite_type' {
export * from '~amqp10/lib/types/composite_type';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/types/delivery_state.d.ts
declare module '~amqp10/lib/types/delivery_state' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import ForcedType = require('~amqp10/lib/types/forced_type');
import { Composite } from '~amqp10/lib/types/composite_type';

export type DeliveryState = Received | Accepted | Rejected | Released | Modified;

export class Received extends Composite implements ReceivedOptions {
    sectionNumber: number;
    sectionOffset: number;
    
    constructor(options: ReceivedOptions);
}
export interface ReceivedOptions {
    sectionNumber: number;
    sectionOffset: number;
}

export class Accepted extends Composite {
    constructor(options: ReceivedOptions);
}

export class Rejected extends Composite implements RejectedOptions {
    error: string;
    
    constructor(options: RejectedOptions);
}
export interface RejectedOptions {
    error?: string;
}

export class Released extends Composite {
    constructor(options: ReceivedOptions);
}

export class Modified extends Composite implements ModifiedOptions {
    deliveryFailed: boolean;
    undeliverableHere: boolean;
    messageAnnotations: Object;
    
    constructor(options: ModifiedOptions);
}
export interface ModifiedOptions {
    deliveryFailed: boolean;
    undeliverableHere: boolean;
    messageAnnotations: Object;
}
}
declare module 'amqp10/lib/types/delivery_state' {
export * from '~amqp10/lib/types/delivery_state';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/sender_link.d.ts
declare module '~amqp10/lib/sender_link' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import Link = require('~amqp10/lib/link');
import Session = require('~amqp10/lib/session');
import Policy = require('~amqp10/lib/policies/policy');
import { DeliveryState } from '~amqp10/lib/types/delivery_state';
import { BaseError } from '~amqp10/lib/errors';

class SenderLink extends Link {
    policy: Policy.SenderLink;
    initialDeliveryCount: number;

    constructor(session: Session, handle: string, linkPolicy: Policy.SenderLink);

    canSend(): boolean;

    /**
     * Sends the given message, with the given options on this link
     *
     * @param {*} msg               Message to send.  Will be encoded using sender link policy's encoder.
     * @param {*} [options]         An object of options to attach to the message including: annotations, properties,
                                    and application properties
    * @param options.annotations   Annotations for the message, if any.  See AMQP spec for details, and server for specific
    *                               annotations that might be relevant (e.g. x-opt-partition-key on EventHub).  If node-amqp-encoder'd
    *                               map is given, it will be translated to appropriate internal types.  Simple maps will be converted
    *                               to AMQP Fields type as defined in the spec.
    */
    send(message: any, options?: SenderLink.MessageOptions | Object): Promise<DeliveryState>;

    /** Error event handler */
    on(event: "errorReceived", listener: (err: BaseError) => void): this;
    on(event: "creditChange" | "attached" | "detached", listener: Function): this;
    on(event: string, listener: Function): this;
}

namespace SenderLink {
    export interface Dictionary<T> {
        [key: string]: T;
    }

    export interface MessageOptions extends Dictionary<any> {
        body: any;

        properties?: Dictionary<any>;

        /**
         * Annotations for the message, if any.  See AMQP spec for details, and server for specific
         * annotations that might be relevant (e.g. x-opt-partition-key on EventHub).  If node-amqp-encoder'd
         * map is given, it will be translated to appropriate internal types.  Simple maps will be converted
         * to AMQP Fields type as defined in the spec.
         */
        annotations?: Dictionary<any>;

        applicationProperties?: Dictionary<any>;
    }
}

export = SenderLink;
}
declare module 'amqp10/lib/sender_link' {
import main = require('~amqp10/lib/sender_link');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/node-amqp10/c42a25c8531690708dee1b99c9b71d720f87316d/lib/index.d.ts
declare module 'amqp10' {
// Type definitions for node-amqp10 v3
// Project: https://github.com/noodlefrenzy/node-amqp10
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/node-amqp10

import _Policy = require('~amqp10/lib/policies/policy');
import _EventHub = require('~amqp10/lib/policies/event_hub_policy');
import _ServiceBusQueue = require('~amqp10/lib/policies/service_bus_queue_policy');
import _ServiceBusTopic = require('~amqp10/lib/policies/service_bus_topic_policy');
import _QpidJava = require('~amqp10/lib/policies/qpid_java_policy');
import _ActiveMQ = require('~amqp10/lib/policies/activemq_policy');
import _Utils = require('~amqp10/lib/policies/policy_utilities');

export import Client = require('~amqp10/lib/amqp_client');
export import Constants = require('~amqp10/lib/constants');
export import Errors = require('~amqp10/lib/errors');

/**
 * Policies encode many of the optional behaviors and settings of AMQP into a
 * cohesive place that could potentially be standardized, could be loaded from
 * JSON, etc.
 */
export namespace Policy {
    export import PolicyBase = _Policy;
    export const Default: _Policy;

    export const EventHub: typeof _EventHub;
    export const ServiceBusQueue: typeof _ServiceBusQueue;
    export const ServiceBusTopic: typeof _ServiceBusTopic;
    export const QpidJava: typeof _QpidJava;
    export const ActiveMQ: typeof _ActiveMQ;

    export import Utils = _Utils;

    /**
     * Create a new Policy by extending the Base Policy.
     *
     * @param overrides - Configuration overrides.
     * @returns Extended configuration.
     */
    export function merge(overrides: Options.Overrides): PolicyBase
    /**
     * Create a new Policy by extending given base policy using given overrides configuration.
     *
     * @param overrides - Configuration overrides.
     * @param base - Base configuration to extend.
     * @returns Extended configuration.
     */
    export function merge(overrides: Options.Overrides, base: PolicyBase): PolicyBase;

    /** Typings only */
    export namespace Options {
        export type Overrides = _Policy.Overrides;
        export type Reconnect = _Policy.Reconnect;
        export type Connect = _Policy.Connect;
        export type ConnectOptions = _Policy.ConnectOptions;
        export type SSLOptions = _Policy.SSLOptions;
        export type Session = _Policy.Session;
        export type SessionOptions = _Policy.SessionOptions;
        export type SenderLink = _Policy.SenderLink;
        export type SenderLinkAttach = _Policy.SenderLinkAttach;
        export type ReceiverLink = _Policy.ReceiverLink;
        export type ReceiverLinkAttach = _Policy.ReceiverLinkAttach;
        export type Address = _Policy.Address;
    }
}

export import TransportProvider = require('~amqp10/lib/transport/index');
export import DescribedType = require('~amqp10/lib/types/described_type');

/**
 * translator, which allows you to translate from node-amqp-encoder'd
 * values into the internal types used in this library. (e.g.
 * [ 'symbol', 'symval' ] => Symbol('symval') ).
 */
export import translator = require('~amqp10/lib/adapters/translate_encoder');

/**
 * Syntactic sugar for pluggable amqp10 Client behaviors.
 */
export function use(plugin: (client: typeof Client) => void): void;

// Typings only
import _ReceiverLink = require('~amqp10/lib/receiver_link');
export type ReceiverLink = _ReceiverLink;
export type Message = _ReceiverLink.Message;
export type ModifyOptions = _ReceiverLink.ModifyOptions;

import _SenderLink = require('~amqp10/lib/sender_link');
export type SenderLink = _SenderLink;
export type MessageOptions = _SenderLink.MessageOptions;
}
